<title>Levels Flow</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="/wp-content/includes/Chart.min.js"></script>
<script src="/wp-content/includes/luxon.min.js"></script>
<script src="/wp-content/includes/chartjs-adapter-luxon.min.js"></script>
<!-- For luxon formatting see https://github.com/moment/luxon/blob/master/docs/formatting.md -->
<script src="/wp-content/includes/chartjs-plugin-annotation.min.js"></script>
<script src="/wp-content/includes/datepicker.min.js"></script>
<link rel="stylesheet" href="/wp-content/includes/datepicker.min.css">

<style>
.tt {
 font-family: Arial, Helvetica, sans-serif;
 font-size: 20px;
 text-align: center;
 margin-bottom: 30px;
}
.notes {
text-align: inherit;
}
.sub1 {
 font-family: Arial, Helvetica, sans-serif;
 font-size: 18px;
 text-align: center;
 padding-right: 60px;
 margin-bottom: 20px;
}
.sub2 {
 font-family: Arial, Helvetica, sans-serif;
 font-size: 18px;
 text-align: center;
 padding-bottom: 20px;
}
.col_wra {
 max-width: 1280px;
 margin: auto;
}
.col_lef {
 max-width: 500px;
 padding-bottom: 40px;
 float: left;
}
.col_rig {
 max-width: 780px;
 padding-bottom: 40px;
 float: left;
}   
.btn {
 font-size: 18px;
 font-family: Arial, Helvetica, sans-serif;
 padding: 10px 16px;
 margin: 5px;
 border-radius: 4px;
 background-color: #d3d3d3;
}
.lab {
 font-family: Arial, Helvetica, sans-serif;
 font-style: normal;
 white-space: nowrap;
}

.active, .btn:hover {
 background-color: #1a73e8;
 color: white;
}
.box {
 width: 420px;
 height: 70px;
 margin: 5px 0;
 padding: 5px 20px 5px 10px;
 font-family: Arial, Helvetica, sans-serif;
 font-size: 22px;
 color: white;
 float: left;
}
.inner {
 height: 70px; 
 margin-top: -20px;
 text-align: right;
 display:flex;                
 align-items: center;
 justify-content: flex-end;
 font-weight: bold;
 color: white;               
}
.fontbig {
 font-size: 38px;            
}
.fontsmall {
 font-size: 25px;            
}
.cwra {
 width: 780px;
 height: 390px;
 margin: auto;
}
.cwra_lev {
 width: 780px;
 height: 430px;
 margin: auto;
}
.cle {
 clear: left;
}
#ts {
 white-space: nowrap;
}
#con {
 max-width: 1280px;
 margin: auto;
 line-height: 1.0;
}
#pan {
 max-width: 760px;
 border: lightgrey solid 2px;
 background-color: #e7e7e7;
 padding-top: 10px;
 margin: 5px auto;
}
#dpk1, #dpk2 {
 margin: 10px;
 font-family: Arial, Helvetica, sans-serif;
 background: white;
 border: 1px solid black;
 width: fit-content;
}
#btw {
 max-width: 780px;
 margin: auto;
 text-align:center;
}
#dtw {
 max-width: 780px;
 margin: auto;
 text-align:center;
}
#up {
 background-color: #418AD9;
}
#do {
 background-color: #418AD9;
}
#he {
 background-color: #418AD9;
}
#ahol {
 background-color: #418AD9;
}
#hol {
 background-color: #418AD9;
}
#flo1 {
 background-color: #37A19D;
}
#flo2 {
 background-color: #37A19D;
}
#EAflo {
 background-color: #3ca650;
}
#ca_lev {
 height: 100%;                          
}
#ca_flo {
 height: 100%;                          
}
#ca_EAflo {
 height: 100%;                          
}

@media only screen and (max-width: 1420px) {
 .col_wra {
  max-width: 580px;                
 }
 .col_lef {
  max-width: 580px;
  float: none;                
 }
 .sub1 {
  padding-right: 0;
 }
 .box {
  float: none;
  margin: 5px auto;
 }
 .col_rig {
  max-width: 580px;                
 }
 .cwra {
  width: 580px;
  height: 290px; 
  margin: auto;        
 }
 .cwra_lev {
  width: 580px;
  height: 320px; 
  margin: auto;   
 }
}
@media only screen and (max-width: 610px) {
 .col_wra {
  max-width: 350px;
 }
 #btw {
  max-width: 300px;
 }
 #dtw {
  width: 300px;
 }                 
 .col_lef {
  max-width: 350px;
  float: none;  
 }
 .sub1, .sub2 {
  padding-right: 0;
  font-size: 17px;
  margin-bottom: 10px;
 }
 .box {
  width: 320px;
  float: none;  
  margin: 5px auto;
  font-size: 20px;
 }
 .fontbig {
  font-size: 30px;
 }
 .fontsmall {
  font-size: 20px;
 }
 .col_rig {
  max-width: 350px;
 }
 .cwra {
  width: 350px;
  height: 290px;
  margin: auto;
 }
 .cwra_lev {
  width: 350px;
  height: 320px;
  margin: auto;
 }
}
@media only screen and (max-width: 360px) {
 .box {
  width: 270px;
  float: none;  
  margin: 5px auto;
  font-size: 18px;
 }
}
</style>

<script type="text/javascript">
//<!--
// DO NOT REMOVE the comment above, it stops Wordpress from escaping ampersands

function buildStaticPage() {
    const container = document.createElement('div');
    container.id = "con";

    container.innerHTML = `
        <p class="notes"><a href="#notes">See below for explanatory notes</a></p>

        <div class="col_wra">
            <div class="col_lef">
                <div class="sub1" id="subtitle_current">Loading current conditions…</div>

                ${makeBox("up", "Upstream (metres AOD)", "upstream")}
                ${makeBox("do", "Downstream (metres AOD)", "downstream")}
                ${makeBox("he", "Head (metres)", "head")}
                ${makeBox("ahol", "Above set level (metres)", "aboveHOL")}
                ${makeBox("hol", "Present set level (metres)", "HOL")}
                ${makeBox("flo1", "Water flow turbine 1 (m³/s)", "flow1")}
                ${makeBox("flo2", "Water flow turbine 2 (m³/s)", "flow2")}
                ${makeBox("EAflo", "Flow at Reading Bridge (m³/s)", "EAflow")}
                <p class="cle"></p>
            </div>

            <div class="col_rig">
                <div class="sub2">Conditions over selected period</div>
                <div id="pan">
                    <div id="btw">
                        <button class="btn active" data-range="day">Last day</button>
                        <button class="btn" data-range="week">Last week</button>
                        <button class="btn" data-range="month">Last month</button>
                        <button class="btn" data-range="year">Last year</button>
                        <p class="cle"></p>
                    </div>
                    <div id="dtw">
                        <label class="lab" for="dpk1">Start date</label>
                        <input id="dpk1" type="text">
                        <label class="lab" for="dpk2">End date</label>
                        <input id="dpk2" type="text">
                        <p class="cle"></p></div>
                </div>

                <div class="cwra_lev"><canvas id="ca_lev"></canvas></div>
                <div class="cwra_lev"><canvas id="ca_flo"></canvas></div>
                <div class="cwra"><canvas id="ca_EAflo"></canvas></div>
            </div>
        </div>
    `;

    document.getElementsByClassName("entry-header")[0].append(container);
}

function makeBox(id, label, valueId) {
    return `
        <div id="${id}" class="box">
            ${label}
            <div class="inner fontbig" id="${valueId}">—</div>
        </div>
    `;
}

function setText(id, value) {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
}

// datepicker
let startdate = luxon.DateTime.now().startOf('day').toJSDate();
let enddate = luxon.DateTime.now().endOf('day').toJSDate();

// push end date to end of day
function dayEnd(pick){
    var dayend = luxon.DateTime.fromJSDate(pick).endOf('day').toJSDate()
    return dayend
}
let picker1, picker2;
function initRangeButtons() {
    document.querySelectorAll('#btw .btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('#btw .btn')
                .forEach(b => b.classList.remove('active'));

            btn.classList.add('active');

            let start = new Date();
            let now = new Date();
            now.setDate(now.getUTCDate());

            switch (btn.dataset.range) {
                case 'week':  start.setDate(now.getUTCDate() - 7); break;
                case 'month': start.setDate(now.getUTCDate() - 31); break;
                case 'year':  start.setDate(now.getUTCDate() - 365); break;
                default:      start.setDate(now.getUTCDate()); break;
            }

            let newstart = luxon.DateTime.fromJSDate(start).startOf('day').toJSDate();
            let newend = luxon.DateTime.now().endOf('day').toJSDate();

            picker1.setMax(newend);
            picker1.setDate(newstart);
            picker2.setDate(newend);
            updateCharts(newstart, newend);
        });
    });
    picker1 = datepicker( "#dpk1" , {
        id: 1,
        dateSelected: startdate,
        maxDate: enddate,
        formatter: (input, date, instance) => {
            input.value = luxon.DateTime.fromJSDate(date).toFormat('yyyy-LL-dd');
        },
        onSelect: instance => {
            if (picker1.dateSelected > picker2.dateSelected) {
                picker2.setDate(picker1.dateSelected);
            }
            document.querySelectorAll('#btw .btn')
                .forEach(b => b.classList.remove('active'));
            updateCharts(picker1.dateSelected, dayEnd(picker2.dateSelected));
        }
    });
    picker2 = datepicker( "#dpk2" , {
        id: 2,
        dateSelected: enddate,
        maxDate: enddate,
        formatter: (input, date, instance) => {
            input.value = luxon.DateTime.fromJSDate(date).toFormat('yyyy-LL-dd');
        },
        onSelect: instance => {
            if (picker1.dateSelected > picker2.dateSelected) {
                picker1.setDate(picker2.dateSelected);
                picker1.setMax(picker2.dateSelected);
            }
            document.querySelectorAll('#btw .btn')
                .forEach(b => b.classList.remove('active'));
            updateCharts(picker1.dateSelected, dayEnd(picker2.dateSelected));
        }
    });
}

let HOL = 36.700;
async function loadCurrentConditions() {
    try {
        const [plc, setlevel, ea] = await Promise.all([
            getPLCDataCurrent(),
            getSetlevel(),
            getEADataCurrent()
        ]);

        HOL = setlevel.level;
        setText(
            "subtitle_current",
            `Current conditions: ${luxon.DateTime.fromISO(plc.received_at).toFormat('yyyy-LL-dd T')} UTC`
        );

        setText("upstream", plc.upstream.toFixed(3));
        setText("downstream", plc.downstream.toFixed(3));
        setText("head", (plc.upstream - plc.downstream).toFixed(3));
        setText("aboveHOL", (plc.upstream - HOL).toFixed(3));
        setText("HOL", HOL.toFixed(3));
        setText("flow1", (plc.gen1_flow_ls / 1000).toFixed(2));
        setText("flow2", (plc.gen2_flow_ls / 1000).toFixed(2));
        setText("EAflow", ea.flow.toFixed(2));
    } catch (e) {
        console.warn("Current conditions update failed", e);
    }
}
async function updateCurrentConditions() {
    try {
        const [plc, ea] = await Promise.all([
            getPLCDataCurrent(),
            getEADataCurrent()
        ]);

        setText(
            "subtitle_current",
            `Current conditions: ${luxon.DateTime.fromISO(plc.received_at).toFormat('yyyy-LL-dd T')} UTC`
        );

        setText("upstream", plc.upstream.toFixed(3));
        setText("downstream", plc.downstream.toFixed(3));
        setText("head", (plc.upstream - plc.downstream).toFixed(3));
        setText("aboveHOL", (plc.upstream - HOL).toFixed(3));
        setText("HOL", HOL.toFixed(3));
        setText("flow1", (plc.gen1_flow_ls / 1000).toFixed(2));
        setText("flow2", (plc.gen2_flow_ls / 1000).toFixed(2));
        setText("EAflow", ea.flow.toFixed(2));
    } catch (e) {
        console.warn("Current conditions update failed", e);
    }
}

async function loadChartData() {
    global_data = await getPLCdata(startdate, enddate);

    renderLevelChart(startdate, enddate);
}

async function loadChartDataEA() { 
    EA_data = await getEAdata(startdate, enddate);
    renderEAChart(startdate, enddate);
}

function myround(value, precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}

//select timescale using parameters from buttons or datepicker
function needsReload(mystart, myend) {

    //if reload is set we need to fetch more data
    var reload = false;

    if (mystart < startdate) {
        reload = true;
        };
    if (myend > enddate) {
        reload = true;
        };
    // If the period is going from more that 336 hours to less then we have 
    // hourly data and need to reload to get 10 minute interval data.
    // simularly if we are going from more than 2232 hours to less, we 
    // are going from daily to hourly data and need to reload.
    var oldlength = enddate - startdate
    var newlength = myend - mystart
    if ( (oldlength > 336*3600000) && (newlength < 336*3600000) ) {
        reload = true
    }
    if ( (oldlength > 2232*3600000) && (newlength < 2232*3600000) ) {
        reload = true
    }
    return reload 
}

let global_data = [];
let EA_data = [];

async function updateCharts(start, end) {
    console.log(`Updating charts ${luxon.DateTime.fromJSDate(start).toFormat('yyyy-LL-dd T')} to ${luxon.DateTime.fromJSDate(end).toFormat('yyyy-LL-dd T')}`);
    // reload page if higher-resolution data is needed
    if (needsReload(start, end)) {
        global_data = await getPLCdata(start, end);
        EA_data = await getEAdata(start, end);
    }
   
    renderLevelChart(start, end);
    renderEAChart(start, end);
}
async function getPLCdata(fromdate, todate){
    const start = luxon.DateTime.fromJSDate(fromdate).toFormat('yyyyLLdd') 
    const end = luxon.DateTime.fromJSDate(todate).toFormat('yyyyLLdd')
    console.log(`Fetching PLC data between ${start} and ${end}`);
    const response = await fetch(`/api/plc/between/${start}/${end}`);
    startdate = fromdate;
    enddate = todate;
    if (!response.ok) {
        throw new Error('HTTP error! status: ${response.status}');
    }
    return await response.json();
}

async function getEAdata(fromdate, todate){
    const start = luxon.DateTime.fromJSDate(fromdate).toFormat('yyyyLLdd')
    const end = luxon.DateTime.fromJSDate(todate).toFormat('yyyyLLdd')
    console.log(`Fetching EA data between ${start} and ${end}`);
    const response = await fetch(`/api/eadata/between/${start}/${end}`);
    if (!response.ok) { 
        throw new Error('HTTP error! status: ${response.status}'); 
    } 
    return await response.json(); 
}

function creatChartDefaults() { 
//Set global defaults for charts
    Chart.defaults.global.tooltips.callbacks.title = function(t, d) {
        return luxon.DateTime.fromMillis(d.labels[t[0].index]).toFormat('yyyy-LL-dd T');}
//    Chart.defaults.global.animation.duration = 0 
    Chart.defaults.global.maintainAspectRatio = false
    Chart.defaults.global.title.display = true
    Chart.defaults.global.title.fontSize = 20
    Chart.defaults.global.title.fontStyle = 'bold'
    Chart.defaults.global.legend.labels.fontSize = 15
    Chart.defaults.global.legend.labels.fontStyle = 'bold'
}

let myChart_levels = null; 
let myChart_flow = null; 
const anno_HOL = {
        type: 'line',
        id: 'line1',
        mode: 'horizontal',
        scaleID: 'y-axis-0',
        value: HOL,
        borderWidth: 1,
        borderDash: [2,2],
        borderColor: '#E4004D',
        label: {
            backgroundColor: 'rgba(255,255,255,0)',
            fontColor: '#E4004D',
            content: 'Present set level',
            position: 'right',
            yAdjust: 10,
            enabled: true,
        }
    }; 

// Change legend click handler to accommodate annotations
// Store the original click handler for reuse
var defaultLegendClickHandler = Chart.defaults.global.legend.onClick;
// New click handler is called from myChart_levels
var newLegendClickHandler = function (e, legendItem) {
    var index = legendItem.datasetIndex;
    var ci = myChart_levels;
    var meta = ci.getDatasetMeta(index);
    
    defaultLegendClickHandler.call(this, e, legendItem);
    if(!ci.isDatasetVisible(0) && ci.isDatasetVisible(1)){ //Downstream only no HOL. 
        ci.config.options.annotation.annotations[0] = ''
        ci.options.scales.yAxes[0] = {
            ticks: {
                        min: ymin2,
                        fontSize: 15,
                        fontStyle: "bold",
                            },
                    scaleLabel: {
                        display: false,                                      
                            },                                  
        };
        ci.update() 
    };
    if (ci.isDatasetVisible(0) && !ci.isDatasetVisible(1)) { //Upstream only.
        ci.config.options.annotation.annotations[0] = anno_HOL;
        ci.options.scales.yAxes[0] = {
            ticks: {min: (Math.min(HOL - 0.02, ymin1)),
                    max: (Math.max(HOL + 0.02, ymax1)),
                    fontSize: 15,
                    fontStyle: "bold",},
            scaleLabel: {display: false,},
        };
        
        ci.update();  
    }
    if (ci.isDatasetVisible(0) && ci.isDatasetVisible(1)){
        ci.config.options.annotation.annotations[0] = anno_HOL
        ci.options.scales.yAxes[0] = {
            ticks: {min: ymin2,
                    max: ymax1,
                    fontSize: 15,
                    fontStyle: "bold",},
            scaleLabel: {display: false},
        };
        ci.update();
    };
};

var ymin1 = 35.0; // set a default minimum for the y axis of the levels graph. 
var ymax1 = 40.0; // set a default maximum for the y axis of the levels graph.
var ymin2 = 0.0; // set a default minimum for the y axis of the flow graph. 
var ymax2 = 8.0; // set a default maximum for the y axis of the flow graph.

function renderLevelChart(start, end) { 
    const xs = []      // array for timestamps for levels and flow graphs
    const ys1 = []     // array for upstream levels for levels graph
    const ys2 = []     // array for downstream levels for levels graph
    const ys3 = []     // array for flow from turbine 1 for flow graph
    const ys4 = []     // array for flow from turbine 2 for flow graph
    
    var selection = global_data.filter(function(item){
        return new Date(item.received_at) >= start &&
            new Date(item.received_at) <= end
    })
    var length = end - start
    var unit = 'hour'
    if (length >= 172800000){
        unit = 'day'
        }

    for(item of selection) {                
        //convert the timestamp to milliseconds (faster)                
        const mydate = new Date(item.received_at).getTime()
        xs.push(mydate);
        ys1.push(item.upstream);
        ys2.push(item.downstream);
        ys3.push((item.gen1_flow_ls/1000).toFixed(2));
        ys4.push((item.gen2_flow_ls/1000).toFixed(2));
    }

    // tweak scales for y axes of graphs
    // upstream/downstream levels
    ymax1 = myround((Math.max(...ys1) + 0.02), 1)
    ymax1 = Math.max(ymax1, HOL + 0.02)
    ymin1 = myround((Math.min(...ys1) - 0.02), 1)
    ymin2 = myround((Math.min(...ys2) - 0.02), 1)
    if (ymin2 > 35.0){ymin2 = 35.0} // but not greater than 35.0

    if (typeof myChart_levels !== 'undefined' && myChart_levels) {
        myChart_levels.destroy();
    }

    var ctx_lev = document.getElementById('ca_lev').getContext('2d');
    myChart_levels = new Chart(ctx_lev, {
        type: 'line', data: {
            labels: xs,
            datasets: [{       
                label: 'Upstream',                         
                data: ys1,
                fill: true,
                backgroundColor: 'rgba(136, 209, 230, 0.6)',
                borderColor: 'rgba(136, 209, 230, 0.6)',
                borderWidth: 1,
                radius: 0,
            },{  
                label: 'Downstream',                              
                data: ys2,
                fill: true,
                backgroundColor: 'rgba(64, 154, 230, 0.9)',
                borderColor: 'rgba(64, 154, 230, 0.9)',
                borderWidth: 1,
                radius: 0,
                },                        
            ]},
        options: {
            annotation: {
                drawTime: 'afterDraw',
                annotations: [anno_HOL],
            },
            scales: {
                xAxes: [{
                    type: 'time',
                    time: {minUnit: unit,
                           tooltipFormat: 'yyyy-LL-dd T',},
                    distribution: 'linear',
                    ticks: {
                        fontStyle: "bold",
                        min: start,
                        max: end,},
                        scaleLabel: {display: false,},
                }],
                yAxes: [{
                    ticks: {
                        min: ymin2,
                        max: ymax1,
                        fontSize: 15,
                        fontStyle: "bold",
                    },
                    scaleLabel: {display: false,},
                }]
            },
            title: {
                text: "Water levels (metres AOD)",},
            legend: {
                    display: true,
                    onClick: newLegendClickHandler,
            }
       }
    });
    var ctx_flo = document.getElementById('ca_flo').getContext('2d');
    myChart_flow = new Chart(ctx_flo, {
        type: 'line',
        data: {
            labels: xs,
            datasets: [{
                label: 'Tony (turbine 1)',                     
                data: ys3,
                fill: true,
                backgroundColor: 'rgba(58,170,166,1.0)',
                borderColor: 'rgba(58,170,166,1.0)',
                borderWidth: 1,
                radius: 0
            },{
                label: 'Sophie (turbine 2)',                       
                data: ys4,
                fill: true,
                backgroundColor: 'rgba(128,226,222,1.0)',
                borderColor: 'rgba(128,226,222,1.0)',
                borderWidth: 1,
                radius: 0
            },]
        },
        options: {                                
            scales: {
                xAxes: [{
                    type: 'time', 
                    time: {minUnit: unit,
                           tooltipFormat: 'yyyy-LL-dd T',
                    },
                    distribution: 'linear',
                    ticks: {
                        fontStyle: "bold",
                        min: start,
                        max: end,
                    },
                    scaleLabel: {
                        display: false,
                    },
                }],
                yAxes: [{
                    stacked: true,
                    ticks: {
                        fontSize: 15,
                        fontStyle: "bold",
                    },
                    scaleLabel: {
                        display: false                                      
                    },
                }]
            },
            title: {text: "Flow through turbines (cubic metres/sec)",},
                legend: {display: true,}
        } 
    });                 

}

function renderEAChart(startdate, enddate) {
    const xs = []      // array for timestamps for EA flow graph
    const ys = []      // array for flow at Reading Bridge for EA flow graph
    
    var selection = EA_data.filter(function(item){
        return new Date(item.entrytime) >= startdate &&
            new Date(item.entrytime) <= enddate
    })
    var length = enddate - startdate
    var unit = 'hour'
    if (length >= 172800000){
        unit = 'day'
        }

    for(item of selection) {                
        //convert the timestamp to milliseconds (faster)                
        const mydate = new Date(item.entrytime).getTime()
        xs.push(mydate);
        ys.push(item.flow);
    }
    var ymin3 = 0
    var ymax3 = myround((Math.max(...ys)), 0)
    ymax3 = Math.ceil(ymax3/10)*10
    if (ymax3 < 100){ymax3 = 100}

    var ctx_EAflo = document.getElementById('ca_EAflo').getContext('2d');
    if (typeof myChart_EAflo !== 'undefined' && myChart_EAflo) {
        myChart_EAflo.destroy();
    }
    myChart_EAflo = new Chart(ctx_EAflo, {
        type: 'line',
        data: {
            labels: xs,
            datasets: [{
                label: 'Flow at Reading Bridge',                     
                data: ys,
                fill: true,
                backgroundColor: 'rgba(60,166,80,1.0)',
                borderColor: 'rgba(60,166,80,1.0)',
                borderWidth: 1,
                radius: 0
            },]
        },
        options: {                                
            scales: {
                xAxes: [{
                    type: 'time', 
                    time: {minUnit: unit,
                           tooltipFormat: 'yyyy-LL-dd T',
                    },
                    distribution: 'linear',
                    ticks: {
                        fontStyle: "bold",
                        min: startdate,
                        max: enddate,
                    },
                    scaleLabel: {
                        display: false,
                    },
                }],
                yAxes: [{
                    ticks: {
                        min: ymin3,
                        max: ymax3,
                        fontSize: 15,
                        fontStyle: "bold",
                    },
                    scaleLabel: {
                        display: false                                      
                    },
                }]
            },
            title: {text: "Flow at Reading Bridge (cubic metres/sec)",},
                legend: {display: true,}
        } 
    });                 

}

let plcCache = null;
let plcTime = 0;
async function getPLCDataCurrent() {
    const interval = Date.now() - plcTime;
    if (interval < 600_000 && plcCache) {
        return plcCache;
    }
    plcCache = await fetch('/api/plc/current')
        .then(res => res.json());
    plcTime = Date.parse(plcCache.received_at);
    return plcCache;
}

async function getSetlevel() { 
    const response = await fetch('/api/setlevel/current');
    if (!response.ok) { throw new Error('HTTP error! status: ${response.status}');
    } return await response.json(); 
}

let EAcache = null;
let EAtime = 0;
async function getEADataCurrent() { 
    const interval = Date.now() - EAtime;
    if (interval < 7_200_000 && EAcache) {
        return EAcache;
    }
    const response = await fetch('/api/eadata/current'); 
    if (!response.ok) { throw new Error('HTTP error! status: ${response.status}'); 
    } 
    EAcache = await response.json();
    EAtime = Date.now();
    return EAcache;
}

buildStaticPage();
initRangeButtons();

// initial load
startdate = luxon.DateTime.now().startOf('day').toJSDate();
enddate = luxon.DateTime.now().endOf('day').toJSDate();
loadCurrentConditions();
creatChartDefaults();
loadChartData();
loadChartDataEA();

// refresh current conditions every 60 seconds
setInterval(updateCurrentConditions, 60_000);

// refresh immediately when tab becomes visible
document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
        updateCurrentConditions();
    }
});
//-->
</script>
