<title>Levels Flow</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="/wp-content/includes/Chart.min.js"></script>
<script src="/wp-content/includes/luxon.min.js"></script>
<script src="/wp-content/includes/chartjs-adapter-luxon.min.js"></script>
<!-- For luxon formatting see https://github.com/moment/luxon/blob/master/docs/formatting.md -->
<script src="/wp-content/includes/chartjs-plugin-annotation.min.js"></script>
<script src="/wp-content/includes/datepicker.min.js"></script>
<link rel="stylesheet" href="/wp-content/includes/datepicker.min.css">
<link rel="stylesheet" href="/wp-content/includes/hydrodata.css">

<script type="text/javascript">
//<!--
// DO NOT REMOVE the comment above, it stops Wordpress from escaping ampersands

function buildStaticPage() {
    const container = document.createElement('div');
    container.id = "con";

    container.innerHTML = `
        <p class="notes"><a href="#notes">See below for explanatory notes</a></p>

        <div class="col_wra">
            <div class="col_lef">
                <div class="sub1" id="subtitle_current">Loading current conditions…</div>

                ${makeBox("up", "Upstream (metres AOD)", "upstream")}
                ${makeBox("do", "Downstream (metres AOD)", "downstream")}
                ${makeBox("he", "Head (metres)", "head")}
                ${makeBox("ahol", "Above set level (metres)", "aboveHOL")}
                ${makeBox("hol", "Present set level (metres)", "HOL")}
                ${makeBox("flo1", "Water flow turbine 1 (m³/s)", "flow1")}
                ${makeBox("flo2", "Water flow turbine 2 (m³/s)", "flow2")}
                ${makeBox("EAflo", "Flow at Reading Bridge (m³/s)", "EAflow")}
                <p class="cle"></p>
            </div>

            <div class="col_rig">
                <div class="sub2">Conditions over selected period</div>
                <div id="pan">
                    <div id="btw">
                        <button class="btn active" data-range="day">Last day</button>
                        <button class="btn" data-range="week">Last week</button>
                        <button class="btn" data-range="month">Last month</button>
                        <button class="btn" data-range="year">Last year</button>
                        <p class="cle"></p>
                    </div>
                    <div id="dtw">
                        <label class="lab" for="dpk1">Start date</label>
                        <input id="dpk1" type="text">
                        <label class="lab" for="dpk2">End date</label>
                        <input id="dpk2" type="text">
                        <p class="cle"></p></div>
                </div>

                <div class="cwra_lev"><canvas id="ca_lev"></canvas></div>
                <div class="cwra_lev"><canvas id="ca_flo"></canvas></div>
                <div class="cwra"><canvas id="ca_EAflo"></canvas></div>
            </div>
        </div>
    `;

    document.getElementsByClassName("entry-header")[0].append(container);
}

function makeBox(id, label, valueId) {
    return `
        <div id="${id}" class="box">
            ${label}
            <div class="inner fontbig" id="${valueId}">—</div>
        </div>
    `;
}

function setText(id, value) {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
}

function initRangeButtons() {
    document.querySelectorAll('#btw .btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('#btw .btn')
                .forEach(b => b.classList.remove('active'));

            btn.classList.add('active');

            const now = new Date();
            let start = new Date();

            switch (btn.dataset.range) {
                case 'week':  start.setDate(now.getUTCDate() - 7); break;
                case 'month': start.setDate(now.getUTCDate() - 31); break;
                case 'year':  start.setDate(now.getUTCDate() - 365); break;
                default:      start.setDate(now.getUTCDate()); break;
            }

            let newstart = luxon.DateTime.fromJSDate(start).startOf('day').toJSDate();
            let newend = luxon.DateTime.now().endOf('day').toJSDate();

            setText("dpk1",luxon.DateTime.fromJSDate(newstart).toFormat('yyyy-LL-dd')); 
            setText("dpk2",luxon.DateTime.fromJSDate(newend).toFormat('yyyy-LL-dd'));

            updateCharts(newstart, newend);
        });
    });
}


let HOL = 0;
async function loadCurrentConditions() {
    try {
        const [plc, setlevel, ea] = await Promise.all([
            getPLCDataCurrent(),
            getSetlevel(),
            getEADataCurrent()
        ]);

        HOL = setlevel.level;
        setText(
            "subtitle_current",
            `Current conditions: ${luxon.DateTime.fromISO(plc.received_at).toFormat('yyyy-LL-dd T')} UTC`
        );

        setText("upstream", plc.upstream.toFixed(3));
        setText("downstream", plc.downstream.toFixed(3));
        setText("head", (plc.upstream - plc.downstream).toFixed(3));
        setText("aboveHOL", (plc.upstream - HOL).toFixed(3));
        setText("HOL", HOL.toFixed(3));
        setText("flow1", (plc.gen1_flow_ls / 1000).toFixed(2));
        setText("flow2", (plc.gen2_flow_ls / 1000).toFixed(2));
        setText("EAflow", ea.flow.toFixed(2));
    } catch (e) {
        console.warn("Current conditions update failed", e);
    }
}
async function updateCurrentConditions() {
    try {
        const [plc, ea] = await Promise.all([
            getPLCDataCurrent(),
            getEADataCurrent()
        ]);

        setText(
            "subtitle_current",
            `Current conditions: ${luxon.DateTime.fromISO(plc.received_at).toFormat('yyyy-LL-dd T')} UTC`
        );

        setText("upstream", plc.upstream.toFixed(3));
        setText("downstream", plc.downstream.toFixed(3));
        setText("head", (plc.upstream - plc.downstream).toFixed(3));
        setText("aboveHOL", (plc.upstream - HOL).toFixed(3));
        setText("HOL", HOL.toFixed(3));
        setText("flow1", (plc.gen1_flow_ls / 1000).toFixed(2));
        setText("flow2", (plc.gen2_flow_ls / 1000).toFixed(2));
        setText("EAflow", ea.flow.toFixed(2));
    } catch (e) {
        console.warn("Current conditions update failed", e);
    }
}

async function loadChartData() {
    global_data = await getPLCdata(startdate, enddate);

    renderLevelChart(startdate, enddate);
//    renderFlowChart(startdate, enddate);
}

async function loadChartDataEA() { 
    EA_data = await getEAdata(startdate, enddate);
//    renderEAChart(startdate, enddate);
}

function myround(value, precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}

//select timescale using parameters from buttons or datepicker
function needsReload(mystart, myend) {

    //if reload is set we need to fetch more data
    var reload = false

    if (mystart < startdate) {
        reload = true
        }
    // If the period is going from more that 336 hours to less then we have 
    // hourly data and need to reload to get 10 minute interval data.
    // simularly if we are going from more than 2232 hours to less, we 
    // are going from daily to hourly data and need to reload.
    var oldlength = enddate - startdate
    var newlength = myend - mystart
    if ( (oldlength > 336*3600000) && (newlength < 336*3600000) ) {
        reload = true
    }
    if ( (oldlength > 2232*3600000) && (newlength < 2232*3600000) ) {
        reload = true
    }
    return reload 
}

let global_data = [];
let EA_data = [];

async function updateCharts(start, end) {
    // reload page if higher-resolution data is needed
    if (needsReload(start, end)) {
        global_data = await getPLCdata(start, end);
//        EA_data = await getEAdata(start, end);
    }
   
    renderLevelChart(start, end);
//    renderFlowChart(start, end);
//    renderEAChart(start, end);
}
async function getPLCdata(fromdate, todate){
    const start = luxon.DateTime.fromJSDate(fromdate).toFormat('yyyyLLdd') 
    const end = luxon.DateTime.fromJSDate(todate).toFormat('yyyyLLdd')
    console.log(`Fetching PLC data between ${start} and ${end}`);
    const response = await fetch(`/api/plc/between/${start}/${end}`);
    if (!response.ok) {
        throw new Error('HTTP error! status: ${response.status}');
    }
    return await response.json();
}

async function getEAdata(fromdate, todate){
    const start = luxon.DateTime.fromJSDate(fromdate).toFormat('yyyyLLdd')
    const end = luxon.DateTime.fromJSDate(todate).toFormat('yyyyLLdd')
    console.log(`Fetching EA data between ${start} and ${end}`);
    const response = await fetch(`/api/eadata/between/${start}/${end}`);
    if (!response.ok) { 
        throw new Error('HTTP error! status: ${response.status}'); 
    } 
    return await response.json(); 
}
function creatChartDefaults() { 
//Set global defaults for charts
    Chart.defaults.global.tooltips.callbacks.title = function(t, d) {
                            return luxon.DateTime.fromMillis(d.labels[t[0].index]).toFormat('yyyy-LL-dd T');
                                    }
    Chart.defaults.global.animation.duration = 0 
    Chart.defaults.global.maintainAspectRatio = false
    Chart.defaults.global.title.display = true
    Chart.defaults.global.title.fontSize = 20
    Chart.defaults.global.title.fontStyle = 'bold'
    Chart.defaults.global.legend.labels.fontSize = 15
    Chart.defaults.global.legend.labels.fontStyle = 'bold'
    anno_HOL = {
        type: 'line',
        id: 'line1',
        mode: 'horizontal',
        scaleID: 'y-axis-0',
        value: HOL,
        borderWidth: 1,
        borderDash: [2,2],
        borderColor: '#E4004D',
        label: {
            backgroundColor: 'rgba(255,255,255,0)',
            fontColor: '#E4004D',
            content: 'Present set level',
            position: 'right',
            yAdjust: 10,
            enabled: true,
        }
    }
    // Change legend click handler to accommodate annotations
    // Store the original click handler for reuse
    var defaultLegendClickHandler = Chart.defaults.global.legend.onClick;
  
    // New click handler is called from myChart_levels
    var newLegendClickHandler = function (e, legendItem) {
        var index = legendItem.datasetIndex;
        var ci = myChart_levels;
        var meta = ci.getDatasetMeta(index);
        
        defaultLegendClickHandler.call(this, e, legendItem);
        var is_u = ci.isDatasetVisible(0)
        var is_d = ci.isDatasetVisible(1)
        // if downstream only is visible, hide HOL
        // flag is used to avoid Boolean ampersand, which causes problems in Wordpress
            var flag = 0
            if(!is_u){ flag++ }
            if(is_d){ flag++ }
            if (flag == 2) { //downstream only visible. Don't show HOL. 
                ci.config.options.annotation.annotations[0] = ''
                ci.options.scales.yAxes[0] = {
                    ticks: {
                                min: ymin2,
                                fontSize: 15,
                                fontStyle: "bold",
                                    },
                            scaleLabel: {
                                display: false,                                      
                                    },                                  
                };
                ci.update() 
            } else if(flag == 0) { //upstream only visible. Reset min tick value.
                ci.config.options.annotation.annotations[0] = anno_HOL;
                ci.options.scales.yAxes[0] = {
                    ticks: {min: HOL - 0.02,
                            fontSize: 15,
                            fontStyle: "bold",},
                    scaleLabel: {display: false,},
                };
                
                ci.update();  
            } else { //upstream and downstream are both visible. Reset min tick value.
                ci.config.options.annotation.annotations[0] = anno_HOL
                ci.options.scales.yAxes[0] = {
                    ticks: {min: ymin2,
                            max: ymax1,
                            fontSize: 15,
                            fontStyle: "bold",},
                    scaleLabel: {display: false},
                };
                ci.update();
            };
    };

}

let myChart_levels = null; 
let myChart_flow = null; 
let anno_HOL = null; 
let newLegendClickHandler = null;
function renderLevelChart(start, end) { 
    const xs = []
    const ys1 = []
    const ys2 = []
    const ys3 = []
    const ys4 = []
    
    var selection = global_data.filter(function(item){
        return new Date(item.received_at) >= start &&
            new Date(item.received_at) <= end
    })
    var length = end - start
    var unit = 'hour'
    if (length >= 172800000){
        unit = 'day'
        }

    for(item of selection) {                
        //convert the timestamp to milliseconds (faster)                
        const mydate = new Date(item.received_at)
        xs.push(mydate.getTime);
        ys1.push(item.upstream);
        ys2.push(item.downstream);
        ys3.push((item.gen1_flow_ls/1000).toFixed(2));
        ys4.push((item.gen2_flow_ls/1000).toFixed(2));
    }

    // tweak scales for y axes of graphs
    // upstream/downstream levels
    var ymax1 = myround((Math.max(...ys1) + 0.2), 1) // max level plus 0.2
    var ymin2 = myround((Math.min(...ys2) - 0.2), 1) // min level minus 0.2
    if (ymin2 > 35.0){ //don't go above 35 for base level of graph
        ymin2 = 35.0
    }

    if (typeof myChart_levels !== 'undefined' && myChart_levels) {
        myChart_levels.destroy();
    }

    var ctx_lev = document.getElementById('ca_lev').getContext('2d');
    myChart_levels = new Chart(ctx_lev, {
        type: 'line', data: {
            labels: xs,
            datasets: [{       
                label: 'Upstream',                         
                data: ys1,
                fill: true,
                backgroundColor: 'rgba(136, 209, 230, 0.6)',
                borderColor: 'rgba(136, 209, 230, 0.6)',
                borderWidth: 1,
                radius: 0,
            },{  
                label: 'Downstream',                              
                data: ys2,
                fill: true,
                backgroundColor: 'rgba(64, 154, 230, 0.9)',
                borderColor: 'rgba(64, 154, 230, 0.9)',
                borderWidth: 1,
                radius: 0,
                },                        
            ]},
        options: {
            annotation: {
                drawTime: 'afterDraw',
                annotations: [anno_HOL],
            },
            scales: {
                xAxes: [{
                    type: 'time',
                    time: {minUnit: unit},
                    distribution: 'linear',
                    ticks: {
                        fontStyle: "bold",
                        min: start,
                        max: end,},
                        scaleLabel: {display: false,},
                }],
                yAxes: [{
                    ticks: {
                        min: ymin2,
                        max: ymax1,
                        fontSize: 15,
                        fontStyle: "bold",
                    },
                    scaleLabel: {display: false,},
                }]
            },
            title: {
                text: "Water levels (metres AOD)",},
            legend: {
                    display: true,
                    onClick: newLegendClickHandler,
            }
       }
    });
}


let plcCache = null;
let plcTime = 0;
async function getPLCDataCurrent() {
    const interval = Date.now() - plcTime;
    if (interval < 600_000 && plcCache) {
        return plcCache;
    }
    plcCache = await fetch('/api/plc/current')
        .then(res => res.json());
    plcTime = Date.parse(plcCache.received_at);
    return plcCache;
}

async function getSetlevel() { 
    const response = await fetch('/api/setlevel/current');
    if (!response.ok) { throw new Error('HTTP error! status: ${response.status}');
    } return await response.json(); 
}

async function getEADataCurrent() { 
    const response = await fetch('/api/eadata/current'); 
    if (!response.ok) { throw new Error('HTTP error! status: ${response.status}'); 
    } return await response.json(); }

buildStaticPage();
initRangeButtons();

// initial load
let startdate = luxon.DateTime.now().startOf('day').toJSDate();
let enddate = luxon.DateTime.now().endOf('day').toJSDate();
loadCurrentConditions();
creatChartDefaults();
loadChartData();
loadChartDataEA();

// refresh current conditions every 60 seconds
setInterval(updateCurrentConditions, 60_000);

// refresh immediately when tab becomes visible
document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
        updateCurrentConditions();
    }
});
//-->
</script>
